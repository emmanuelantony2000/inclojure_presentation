<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wasm on Clojure</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/code_styles/atelier-dune-dark.css">
    <!-- Printing and PDF exports -->
    <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
    </script>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <h1>Wasm on Clojure</h1>
            </section>
            <section>
                <p>Twitter: @EmmanuelAntony5</p>
                <p>Github: emmanuelantony2000</p>
                <br>
                <p>I am a Rust developer from Kochi. I am a student currently pursuing BTech in Computer Science.</p>
            </section>
            <section>
                <h2>Topics</h2>
                <ul>
                    <li>What is Wasm?</li>
                    <li>Where can you run Wasm?</li>
                    <li>How to run Wasm on top of JVM?</li>
                    <li>Calling Wasm code from Clojure. (Live demo)</li>
                </ul>
            </section>
            <section>
                <section>
                    <h1>What is Wasm?</h1>
                    <p class="fragment fade-up">Wasm (or WebAssembly) is a standard for a portable binary code format for a stack based virtual machine.</p>
                </section>
                <section>
                    <h2>WebAssembly comes in two flavours</h2>
                    <ul>
                        <li>The .wat (WebAssembly Text) text format that uses S-expressions</li>
                        <li>The .wasm binary format is low level and intended to be consumed by Wasm virtual machines.</li>
                    </ul>
                </section>
                <section>
                    <h2>Let's see a Rust function</h2>
                    <pre><code class="rust" data-trim data-line-numbers data-noescape>
#[no_mangle]
pub extern &quot;C&quot; fn add(x: i32, y: i32) -> i32 {
    x + y
}
                    </code></pre>
                </section>
                <section>
                    <h2>What does .wat look like?</h2>
                    <pre><code data-trim data-line-numbers data-noescape>
(module
(type $t0 (func (param i32 i32) (result i32)))
(func $add (export "add") (type $t0)
    (param $p0 i32) (param $p1 i32) (result i32)
    get_local $p1
    get_local $p0
    i32.add)
(memory $memory (export "memory") 17))
                    </code></pre>
                </section>
                <section>
                    <h2>This is how .wasm looks like</h2>
                    <pre><code class="wasm" data-trim data-line-numbers data-noescape>
0x00000000 0061736D0100000001070160027F7F01 .asm.......`....
0x00000010 7F030201000503010011071002066D65 ..............me
0x00000020 6D6F727902000361646400000A090107 mory...add......
0x00000030 00200120006A0B000B076C696E6B696E . . .j....linkin
0x00000040 67030100                         g...
                    </code></pre>
                </section>
                <section>
                    <p>
                        Because Wasm is so portable being a very small file after compiling, carrying near native performance, 
                        it can be used as a portable binary. C was the portable assembly, and Wasm is the portable binary.
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h1>Where can you run Wasm?</h1>
                </section>
                <section>
                    <p>Wasm can be run using a JIT or an AOT compiler.</p>
                    <br>
                    <p>
                        Wasm is about 20% slower than native performance making it ideal for being used in resource intensive applications on the web.
                        Also it is cross platform making it easy for developers to develop on it.
                        Wasm is also gaining some traction on embedded devices as it does not have a garbage collector. (for now)
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h1>How to run Wasm on top of JVM?</h1>
                </section>
                <section>
                    <p>
                        There are tools like asmble to run .wat files on top of JVM.
                        You can also directly convert Clojure code to .wat files
                    </p>
                </section>
                <section>
                    <p>
                        The thing about Wasm is in its interoperability. Once compiled to .wasm the binary file can be run anywhere.
                        Even called from other languages.
                    </p>
                </section>
                <section>
                    <p>
                        A nice way to run Wasm is by using Wasmer, which is a standalone runtime for Wasm.
                    </p>
                </section>
            </section>
            <section>
                <section>
                    <h1>Calling Wasm code from Clojure.</h1>
                </section>
                <section>
                    When using cljs, wasm code can be called using a js function.
                    <pre class="fragment fade-up"><code class="js" data-line-numbers="1,7" data-trim data-noescape>
fetch&lpar;&apos;../out/main.wasm&apos;&rpar;.then&lpar;response =>
    response.arrayBuffer&lpar;&rpar;
    &rpar;.then&lpar;bytes => WebAssembly.instantiate&lpar;bytes&rpar;&rpar;.then&lpar;
        results => {
        instance = results.instance;
        document.getElementById&lpar;&quot;container&quot;&rpar;.textContent = 
        instance.exports.fib&lpar;12&rpar;;
    }&rpar;.catch&lpar;console.error&rpar;;
                    </code></pre>
                </section>
                <section>
                    <h2>For the Demo</h2>
                    <p>Wrote a Rust function for calculating the nth Fibonacci number</p>
                    <pre><code class="rust" data-line-numbers data-noescape data-trim>
#[no_mangle]
pub extern "C" fn fib(x: i32) -> i32 {
    if x == 0 || x == 1 {
        1
    } else {
        fib(x - 1) + fib(x - 2)
    }
}
                    </code></pre>
                </section>
                <section>
                    <h3>Wrote the same function in cljs</h3>
                    <pre><code class="clojure" data-line-numbers data-noescape data-trim>
(defn fib [n]
  (if (> n 1)
    (+ (fib (dec n)) (fib (- n 2)))
    1))
                    </code></pre>
                </section>
                <section data-background-iframe="https://alphacoder.me/wasm_cljs/index.html" data-background-interactive>
                    <div style="position: absolute; width: 25vh; height: 40vh; right: 0; box-shadow: 0 1px 4px rgba(0,0,0,0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(0, 0, 0, 0.9); color: #fff; padding: 10px; font-size: 20px; text-align: center;">
                        <img src="images/qr.png" style="border: none;" alt="Qr-code">
                        <p>Keep on clicking to see the lag.</p>
					</div>
                </section>
            </section>
            <section>
                <section>
                    <h1>Can this be a bridge between Clojure and Rust?</h1>
                </section>
                <section>
                    <p>
                        Yes, this definitely is a way by which Clojure Applications, specially CojureScript can be supercharged.
                    </p>
                </section>
                <section>
                    <p>You can write the heavy duty WebGl and other compute intensive code in Rust and can call it from cljs.</p>
                    <p>If you are using Clojure, then IO and similar stuff can be written in Rust.</p>
                </section>
            </section>
            <section>
                <h1>Thank You!</h1>
            </section>
        </div>
    </div>
    <script src="js/reveal.js"></script>
    <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
        controls: true,
        progress: true,
        center: true,
        hash: true,
        dependencies: [
            { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
            { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
            { src: 'plugin/notes/notes.js', async: true },
            {
                src: 'plugin/highlight/highlight.js',
                callback: function() {
                    hljs.configure({ useBR: false });
                    hljs.initHighlightingOnLoad();
                },
                async: true
            },
            { src: 'plugin/notes/notes.js', async: true },
        ]
    });
    </script>
</body>

</html>